# Conceptual Aside
## Built-in Function Constructors
### Test in console
`> var a = new Number(3)`

* Then type:

`> a`

* You will see that `a` is not a Number, It is not a primitive
* It is an object!
* Because function constuctors create empty objects
    - And in this case it added a primitive value inside it
    - But because it is an object it has a **prototype**
        + `> Number.prototype`
        + which is what all number objects will have access to
        + And has built in methods like toPrecision and toFixed
        + `a.toFixed(2)`
            * returns "3.00"
* `var a = new String('John')`
    - Now I have access to a whole bunch of things because although they don't live on String, they do live on String.prototype
        + `String.prototype.indexOf('o')` ---> -1
        + But
            * `a.indexOf('o')` ---> 1 (returns the position it found the match)
                - Because the `this` changes
    - But note that String is not a String, aka a primitive
        + `> a`
            * It is an object and it has all of these methods and properties on it
            * And **boxed** inside of it is the primitive value itself

* These function constructors look like you are creating primitives but you're not
    - You are creating objects that contain primitives and give them extra abilities 
* The JavaScript Engine might assume stuff for you
    - `"John".length`
        + John is just a string
        + But the JavaScript Engine boxed it inside of a String object which has all these properties and methods and then gave me access to `"John".length` automatically
        + IT would be the same as implicitly typing `new String("John").length`

### Whenever you see `new` you will get an object back
`var a = new Date("3/1/2025")`

* `a.` - will give you a whole bunch of properties and methods because `a` is an object
    - All of these features are provided under **prototype**
    - They are not living on `a`
    - They are living on Data.prototype

## This is usefull
* When you are building extra features in libraries or frameworks to tak on to the primitive values or arrays, objects or functions

#### I want to add a feature to all strings in JavaScript
```js
String.prototype.isLengthGreaterThan = function(limit) {
  return this.length > limit;
};

console.log('John'.isLengthGreaterThan(3));
```

* Will return `true`
* What just happened?
    - The primitive string was converted to an object generated by the String prototype function
    - I added a method to the prototype
    - So all strings instantly have access to this method
    - Many libraries use this technique to add features
        + to add concepts, ideas, utilities
        + you have to be careful
        + You don't want to overwrite a preexisting method or property

## Can I do this with numbers?
```js
Number.prototype.isPositive = function() {
  return this > 0;
};

console.log(5.isPositive());
```

* We will get an error
* The JavaScript Engine converts Strings to object for me automatically but it won't do that for Numbers

But if you do this:

`> var b = new Number(3)`

And then

`> b.isPositive()` will give you true
